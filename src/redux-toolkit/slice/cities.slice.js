/*
1. Redux Slice Definition (userCitySlice):
Name: "addcity"
Initial State:
userCityDetails: An array to store user's favorite city details.
alreadyAdded: A boolean indicating whether a city is already added (not used in the provided code).
fetchingError: A boolean to track if there's an error during data fetching.

2. Redux Extra Reducers:
Handles asynchronous actions (addCity, removeCity, getCityDetails) using Redux Toolkit's createAsyncThunk.
Handles pending, fulfilled, and rejected states for each asynchronous action.

3. Async Thunks (addCity, removeCity, getCityDetails):

addCity:
Adds a city to the user's favorite cities in Firestore.
Returns updated favorite cities after adding the new city.

removeCity:
Removes a city from the user's favorite cities in Firestore.
Returns updated favorite cities after removing the specified city.

getCityDetails:
Retrieves the user's favorite cities from Firestore.
Returns the list of user's favorite cities.

4. Exported Actions:
cityActions: Contains the actions generated by the createSlice for handling state updates.

5. Exported Default:
The default export is the created userCitySlice which includes the slice's reducer and actions.
*/

import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import { doc, updateDoc, arrayUnion, getDoc, arrayRemove } from 'firebase/firestore';
import { db } from "../../firebase/firebase.config"

const initialState = {
    userCityDetails: [],
    alreadyAdded: false,
    fetchingError: false
}

const userCitySlice = createSlice({
    name: "addcity",
    initialState: initialState,
    extraReducers: (builder) => {
        builder
            .addCase(addCity.pending, (state, action) => {
                state.fetchingError = false
            })
            .addCase(addCity.fulfilled, (state, action) => {
                state.userCityDetails = action.payload
                state.fetchingError = false

            })
            .addCase(addCity.rejected, (state, action) => {
                state.fetchingError = true
            })

            .addCase(removeCity.pending, (state, action) => {
                state.fetchingError = false;
            })
            .addCase(removeCity.fulfilled, (state, action) => {
                state.userCityDetails = action.payload;
                state.fetchingError = false;
            })
            .addCase(removeCity.rejected, (state, action) => {
                state.fetchingError = true;
            })

            .addCase(getCityDetails.pending, (state, action) => {
                state.fetchingError = false;
            })
            .addCase(getCityDetails.fulfilled, (state, action) => {
                state.userCityDetails = action.payload;
                state.fetchingError = false;
            })
            .addCase(getCityDetails.rejected, (state, action) => {
                state.fetchingError = true;
            });
    }
})

export const cityActions = userCitySlice.actions;
export default userCitySlice;

export const addCity = createAsyncThunk("addCityfav", async ({ userAuth, city }) => {
    const document = doc(db, "users", userAuth.uid)
    await updateDoc(document, {
        favCities: arrayUnion(city),
    });
    const updatedCities = await getDoc(document)
    const updatedResult = updatedCities.data().favCities ? updatedCities.data().favCities : []
    return updatedResult
})

export const removeCity = createAsyncThunk("removeCityfav", async ({ userAuth, city }) => {
    const document = doc(db, "users", userAuth.uid);
    await updateDoc(document, {
        favCities: arrayRemove(city),
    });
    const updatedCities = await getDoc(document);
    const updatedResult = updatedCities.data().favCities ? updatedCities.data().favCities : [];
    return updatedResult;
});

export const getCityDetails = createAsyncThunk("getFavCities", async ({ signInCredential }) => {
    const document = doc(db, "users", signInCredential.uid);
    const updatedCities = await getDoc(document);
    const updatedResult = updatedCities.data().favCities ? updatedCities.data().favCities : [];
    return updatedResult;
})